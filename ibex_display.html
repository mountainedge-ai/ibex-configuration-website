<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MountAIn Web Monitor - RAW8 & RGB</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, sans-serif; background: #121212; color: white; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        .card { background: #1e1e1e; padding: 20px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); text-align: center; }
        canvas { border: 2px solid #333; background: #000; display: block; width: 640px; height: 640px; image-rendering: pixelated; }
        .controls { display: flex; gap: 15px; align-items: center; margin-bottom: 15px; }
        
        button { border: none; padding: 12px 24px; border-radius: 6px; cursor: pointer; font-weight: bold; min-width: 160px; transition: 0.3s; }
        .btn-start { background: #00e676; color: #000; }
        .btn-stop { background: #ff5252; color: white; }
        
        .stats { font-family: monospace; font-size: 13px; background: #000; padding: 8px 15px; border-radius: 4px; border: 1px solid #333; flex-grow: 1; display: flex; justify-content: space-around; gap: 10px; }
        .label { color: #888; margin-right: 5px; }
        .value { color: #00e676; font-weight: bold; }
        #perf { margin-top:10px; font-size: 11px; color: #666; font-family: monospace; text-align: left; width: 100%; }
    </style>
</head>
<body>

    <h2>
        <span class="brand">
            <img src="mountain.png" alt="MountAIn logo" width="150" height="49" style="vertical-align: middle; display: inline-block;"/>
        </span>
        <span style="vertical-align: middle; margin-left:10px;">IBEX Stream <small style="opacity: 0.5;"></small></span>
    </h2>

    <div class="card">
        <div class="controls">
            <button id="toggleBtn" class="btn-start">START STREAM</button>
            <div class="stats">
                <div><span class="label">FMT:</span><span id="fmt" class="value">--</span></div>
                <div><span class="label">FPS:</span><span id="fps" class="value">0</span></div>
                <div><span class="label">BUF:</span><span id="buf" class="value">0</span> KB</div>
            </div>
        </div>

        <canvas id="canvas" width="640" height="640"></canvas>
        
        <div id="perf">Status: Disconnected</div>
    </div>

    <script>
        const toggleBtn = document.getElementById('toggleBtn');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const fpsTxt = document.getElementById('fps');
        const fmtTxt = document.getElementById('fmt');
        const bufTxt = document.getElementById('buf');
        const perfTxt = document.getElementById('perf');

        // Constants
        const HEADER = [0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55];
        const BAUD_RATE = 4921600;
        const IMG_W = 640;
        const IMG_H = 640;
        const BBOX_SIZE = 16;

        let port = null;
        let reader = null;
        let isRunning = false;
        let mainBuffer = new Uint8Array(0);
        let frameCount = 0;
        let lastFpsTime = performance.now();
        const rgbaArray = new Uint8ClampedArray(IMG_W * IMG_H * 4);

        // Simple White Balance Gains (Adjust these if colors look off)
        const WB_GAINS = { r: 1.1, g: 1.0, b: 1.3 };

        toggleBtn.addEventListener('click', async () => {
            if (isRunning) {
                isRunning = false; // Breaking the loop will trigger stopStream()
            } else {
                await startStream();
            }
        });

        async function startStream() {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: BAUD_RATE, bufferSize: 2 * 1024 * 1024 });
                
                isRunning = true;
                toggleBtn.innerText = "STOP STREAM";
                toggleBtn.className = "btn-stop";
                perfTxt.innerText = "Status: Connected";
                
                readLoop();
            } catch (err) {
                perfTxt.innerText = "Error: " + err.message;
            }
        }

        async function stopStream() {
            if (reader) {
                await reader.cancel();
                reader.releaseLock();
                reader = null;
            }
            if (port) {
                await port.close();
                port = null;
            }
            toggleBtn.innerText = "START STREAM";
            toggleBtn.className = "btn-start";
            perfTxt.innerText = "Status: Disconnected";
            fmtTxt.innerText = "--";
            mainBuffer = new Uint8Array(0);
        }

        async function readLoop() {
            while (isRunning && port?.readable) {
                reader = port.readable.getReader();
                try {
                    while (isRunning) {
                        const { value, done } = await reader.read();
                        if (done || !isRunning) break;

                        // Merge new data into buffer
                        let newBuf = new Uint8Array(mainBuffer.length + value.length);
                        newBuf.set(mainBuffer);
                        newBuf.set(value, mainBuffer.length);
                        mainBuffer = newBuf;

                        bufTxt.innerText = Math.round(mainBuffer.length / 1024);
                        processBuffer();

                        // Yield execution to keep the UI responsive (Disconnect button)
                        if (frameCount % 3 === 0) await new Promise(r => setTimeout(r, 0));
                    }
                } catch (err) {
                    console.error("Read error:", err);
                } finally {
                    reader.releaseLock();
                    reader = null;
                }
            }
            await stopStream();
        }

        function processBuffer() {
            while (mainBuffer.length >= 11) {
                // Find Header
                let headIdx = -1;
                for (let i = 0; i <= mainBuffer.length - 6; i++) {
                    if (mainBuffer[i] === 0xAA && mainBuffer[i+1] === 0x55) {
                        headIdx = i; break;
                    }
                }
                if (headIdx === -1) { mainBuffer = mainBuffer.slice(mainBuffer.length - 5); return; }
                if (headIdx > 0) mainBuffer = mainBuffer.slice(headIdx);
                
                if (mainBuffer.length < 11) return;
                const view = new DataView(mainBuffer.buffer, mainBuffer.byteOffset, mainBuffer.byteLength);
                const format = mainBuffer[6];
                const imgSize = view.getUint32(7, true);
                const imgEnd = 11 + imgSize;

                if (mainBuffer.length < imgEnd + 1) return;
                const bboxCount = mainBuffer[imgEnd];
                const pkgEnd = imgEnd + 1 + (bboxCount * BBOX_SIZE) + 16;

                if (mainBuffer.length < pkgEnd) return;

                // 1. Decode Image based on format
                decodeAndRender(mainBuffer.subarray(11, imgEnd), format);

                // 2. Draw Detections
                ctx.strokeStyle = "#00e676";
                ctx.lineWidth = 2;
                ctx.fillStyle = "#00e676";
                ctx.font = "bold 12px monospace";
                for (let i = 0; i < bboxCount; i++) {
                    const off = imgEnd + 1 + (i * BBOX_SIZE);
                    const x1 = view.getUint16(off, true), y1 = view.getUint16(off+2, true);
                    const x2 = view.getUint16(off+4, true), y2 = view.getUint16(off+6, true);
                    ctx.strokeRect(x1, y1, x2-x1, y2-y1);
                    ctx.fillText(`${(view.getFloat32(off+12, true)*100).toFixed(0)}%`, x1, y1 > 15 ? y1-5 : 15);
                }

                // Stats
                fmtTxt.innerText = format === 0 ? "RGB888" : "RAW8-" + format;
                frameCount++;
                let now = performance.now();
                if (now - lastFpsTime >= 1000) {
                    fpsTxt.innerText = frameCount;
                    frameCount = 0;
                    lastFpsTime = now;
                }
                mainBuffer = mainBuffer.slice(pkgEnd);
            }
        }

        function decodeAndRender(data, format) {
            if (format === 0) { // RGB888
                for (let i = 0; i < IMG_W * IMG_H; i++) {
                    const s = i * 3, d = i * 4;
                    rgbaArray[d] = data[s]; rgbaArray[d+1] = data[s+1]; rgbaArray[d+2] = data[s+2]; rgbaArray[d+3] = 255;
                }
            } else if (format >= 3 && format <= 6) { // BAYER RAW8 (RGGB, BGGR, GBRG, GRBG)
                for (let y = 0; y < IMG_H; y++) {
                    const isEvenRow = (y % 2 === 0);
                    for (let x = 0; x < IMG_W; x++) {
                        const i = y * IMG_W + x;
                        const d = i * 4;
                        const isEvenCol = (x % 2 === 0);
                        let r, g, b;

                        // Logic mimics cv2.COLOR_BayerXXXX2BGR_EA
                        if (format === 3) { // RGGB
                            if (isEvenRow) {
                                if (isEvenCol) { r=data[i]; g=data[i+1]; b=data[i+IMG_W+1]; }
                                else { r=data[i-1]; g=data[i]; b=data[i+IMG_W]; }
                            } else {
                                if (isEvenCol) { r=data[i-IMG_W]; g=data[i]; b=data[i+1]; }
                                else { r=data[i-IMG_W-1]; g=data[i-1]; b=data[i]; }
                            }
                        } else if (format === 4) { // BGGR
                            if (isEvenRow) {
                                if (isEvenCol) { b=data[i]; g=data[i+1]; r=data[i+IMG_W+1]; }
                                else { b=data[i-1]; g=data[i]; r=data[i+IMG_W]; }
                            } else {
                                if (isEvenCol) { b=data[i-IMG_W]; g=data[i]; r=data[i+1]; }
                                else { b=data[i-IMG_W-1]; g=data[i-1]; r=data[i]; }
                            }
                        } else if (format === 5) { // GBRG
                            if (isEvenRow) {
                                if (isEvenCol) { g=data[i]; b=data[i+1]; r=data[i+IMG_W]; }
                                else { g=data[i-1]; b=data[i]; r=data[i+IMG_W-1]; }
                            } else {
                                if (isEvenCol) { g=data[i]; r=data[i+1]; b=data[i-IMG_W]; }
                                else { g=data[i-1]; r=data[i]; b=data[i-IMG_W-1]; }
                            }
                        } else if (format === 6) { // GRBG
                            if (isEvenRow) {
                                if (isEvenCol) { g=data[i]; r=data[i+1]; b=data[i+IMG_W]; }
                                else { g=data[i-1]; r=data[i]; b=data[i+IMG_W-1]; }
                            } else {
                                if (isEvenCol) { g=data[i]; b=data[i+1]; r=data[i-IMG_W]; }
                                else { g=data[i-1]; b=data[i]; r=data[i-IMG_W-1]; }
                            }
                        }

                        // Apply Gain & Clip (White Balance equivalent)
                        rgbaArray[d]   = Math.min(255, (r || 0) * WB_GAINS.r);
                        rgbaArray[d+1] = Math.min(255, (g || 0) * WB_GAINS.g);
                        rgbaArray[d+2] = Math.min(255, (b || 0) * WB_GAINS.b);
                        rgbaArray[d+3] = 255;
                    }
                }
            }
            ctx.putImageData(new ImageData(rgbaArray, IMG_W, IMG_H), 0, 0);
        }
    </script>
</body>
</html>
